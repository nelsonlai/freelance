<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>21 - WebGL Textures</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
        }
        .canvas-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin: 20px 0;
        }
        canvas {
            border: 2px solid #444;
            display: block;
            margin: 20px auto;
            background: #000;
        }
        .explanation {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>21 - WebGL Textures</h1>
    
    <div class="explanation">
        <h2>Applying Textures to 3D Objects</h2>
        <p>Learn to load and apply textures to 3D objects. This example shows how to create procedural textures and apply them to a cube and sphere.</p>
    </div>

    <div class="canvas-container">
        <canvas id="myCanvas" width="900" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        let gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            const error = document.createElement('div');
            error.className = 'error';
            error.textContent = 'WebGL is not supported';
            canvas.parentElement.insertBefore(error, canvas);
            gl = null;
        }
        
        if (gl) {
            // ============================================
            // SHADERS WITH TEXTURES
            // ============================================
            
            const vertexShaderSource = `
                attribute vec3 a_position;
                attribute vec2 a_texCoord;
                
                uniform mat4 u_matrix;
                
                varying vec2 v_texCoord;
                
                void main() {
                    gl_Position = u_matrix * vec4(a_position, 1.0);
                    v_texCoord = a_texCoord;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                
                uniform sampler2D u_texture;
                varying vec2 v_texCoord;
                
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord);
                }
            `;
            
            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }
            
            function createProgram(gl, vs, fs) {
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                return program;
            }
            
            function multiplyMatrices(a, b) {
                const result = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return result;
            }
            
            function perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const rangeInv = 1 / (near - far);
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ]);
            }
            
            function translate(m, x, y, z) {
                return multiplyMatrices(m, new Float32Array([
                    1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1
                ]));
            }
            
            function rotateY(m, angle) {
                const c = Math.cos(angle), s = Math.sin(angle);
                return multiplyMatrices(m, new Float32Array([
                    c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
                ]));
            }
            
            function rotateX(m, angle) {
                const c = Math.cos(angle), s = Math.sin(angle);
                return multiplyMatrices(m, new Float32Array([
                    1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1
                ]));
            }
            
            function identity() {
                return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
            }
            
            // ============================================
            // CREATE TEXTURED CUBE
            // ============================================
            
            function createTexturedCube() {
                const size = 1.0;
                const positions = [
                    // Front
                    -size, -size,  size,  size, -size,  size,  size,  size,  size,
                    -size, -size,  size,  size,  size,  size, -size,  size,  size,
                    // Back
                    -size, -size, -size, -size,  size, -size,  size,  size, -size,
                    -size, -size, -size,  size,  size, -size,  size, -size, -size,
                    // Top
                    -size,  size, -size, -size,  size,  size,  size,  size,  size,
                    -size,  size, -size,  size,  size,  size,  size,  size, -size,
                    // Bottom
                    -size, -size, -size,  size, -size, -size,  size, -size,  size,
                    -size, -size, -size,  size, -size,  size, -size, -size,  size,
                    // Right
                     size, -size, -size,  size,  size, -size,  size,  size,  size,
                     size, -size, -size,  size,  size,  size,  size, -size,  size,
                    // Left
                    -size, -size, -size, -size, -size,  size, -size,  size,  size,
                    -size, -size, -size, -size,  size,  size, -size,  size, -size,
                ];
                
                const texCoords = [
                    // Front
                    0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
                    // Back
                    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
                    // Top
                    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
                    // Bottom
                    0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
                    // Right
                    0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
                    // Left
                    0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
                ];
                
                return { positions, texCoords, count: 36 };
            }
            
            // ============================================
            // CREATE PROCEDURAL TEXTURE
            // ============================================
            
            function createCheckerTexture(size = 256) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                
                const data = new Uint8Array(size * size * 4);
                const checkSize = size / 8;
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const index = (y * size + x) * 4;
                        const checkX = Math.floor(x / checkSize);
                        const checkY = Math.floor(y / checkSize);
                        const isWhite = (checkX + checkY) % 2 === 0;
                        
                        if (isWhite) {
                            data[index] = 255;     // R
                            data[index + 1] = 255; // G
                            data[index + 2] = 255; // B
                            data[index + 3] = 255; // A
                        } else {
                            data[index] = 100;     // R
                            data[index + 1] = 150; // G
                            data[index + 2] = 200; // B
                            data[index + 3] = 255; // A
                        }
                    }
                }
                
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                
                return texture;
            }
            
            function createGradientTexture(size = 256) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                
                const data = new Uint8Array(size * size * 4);
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const index = (y * size + x) * 4;
                        data[index] = (x / size) * 255;     // R
                        data[index + 1] = (y / size) * 255; // G
                        data[index + 2] = 200;              // B
                        data[index + 3] = 255;              // A
                    }
                }
                
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                
                return texture;
            }
            
            // ============================================
            // INITIALIZE
            // ============================================
            
            const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = createProgram(gl, vs, fs);
            
            const cube = createTexturedCube();
            
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.positions), gl.STATIC_DRAW);
            
            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.texCoords), gl.STATIC_DRAW);
            
            const texture1 = createCheckerTexture();
            const texture2 = createGradientTexture();
            
            // ============================================
            // RENDERING
            // ============================================
            
            let rotation = 0;
            let useTexture1 = true;
            
            function draw() {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.1, 0.1, 0.15, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                gl.useProgram(program);
                
                // Setup position
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                const posLoc = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
                
                // Setup texture coordinates
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                const texLoc = gl.getAttribLocation(program, 'a_texCoord');
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
                
                // Bind texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, useTexture1 ? texture1 : texture2);
                gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);
                
                // Create matrices
                let matrix = identity();
                matrix = translate(matrix, -2, 0, -5);
                rotation += 0.01;
                matrix = rotateY(matrix, rotation);
                matrix = rotateX(matrix, rotation * 0.5);
                
                const aspect = canvas.width / canvas.height;
                const proj = perspective(Math.PI / 4, aspect, 0.1, 100);
                let mvp = multiplyMatrices(proj, matrix);
                
                gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, mvp);
                
                // Draw first cube
                gl.drawArrays(gl.TRIANGLES, 0, cube.count);
                
                // Draw second cube with different texture
                matrix = identity();
                matrix = translate(matrix, 2, 0, -5);
                matrix = rotateY(matrix, -rotation);
                matrix = rotateX(matrix, -rotation * 0.5);
                mvp = multiplyMatrices(proj, matrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, mvp);
                gl.bindTexture(gl.TEXTURE_2D, useTexture1 ? texture2 : texture1);
                gl.drawArrays(gl.TRIANGLES, 0, cube.count);
                
                requestAnimationFrame(draw);
            }
            
            // Toggle textures on click
            canvas.addEventListener('click', () => {
                useTexture1 = !useTexture1;
            });
            
            draw();
        }
    </script>
</body>
</html>

