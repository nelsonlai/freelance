<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>14 - Advanced Animations</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
        }
        .canvas-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin: 20px 0;
        }
        canvas {
            border: 2px solid #444;
            display: block;
            margin: 20px auto;
            background: #000;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background: #4ECDC4;
            border: none;
            border-radius: 5px;
            color: white;
        }
        button:hover {
            background: #3bb5ad;
        }
        .explanation {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>14 - Advanced Animation Techniques</h1>
    
    <div class="explanation">
        <h2>Easing, Interpolation, and Physics</h2>
        <p>Advanced animation techniques: easing functions for smooth motion, interpolation for transitions, and physics-based animations.</p>
    </div>

    <div class="controls">
        <button id="easingBtn">Easing Examples</button>
        <button id="physicsBtn">Physics Simulation</button>
        <button id="waveBtn">Wave Animation</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div class="canvas-container">
        <canvas id="myCanvas" width="900" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        
        let animationMode = 'easing';
        
        // ============================================
        // 1. EASING FUNCTIONS
        // ============================================
        
        const easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeInBounce: t => 1 - easingFunctions.easeOutBounce(1 - t),
            easeOutBounce: t => {
                if (t < 1 / 2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2 / 2.75) {
                    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                } else if (t < 2.5 / 2.75) {
                    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                }
            },
            easeInElastic: t => {
                if (t === 0) return 0;
                if (t === 1) return 1;
                return -Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.1) * 5 * Math.PI);
            },
            easeOutElastic: t => {
                if (t === 0) return 0;
                if (t === 1) return 1;
                return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1;
            }
        };
        
        // Easing animation objects
        const easingObjects = [];
        const easingNames = Object.keys(easingFunctions);
        
        function initEasing() {
            easingObjects.length = 0;
            const spacing = canvas.width / (easingNames.length + 1);
            easingNames.forEach((name, index) => {
                easingObjects.push({
                    name: name,
                    x: spacing * (index + 1),
                    startY: 100,
                    endY: 500,
                    progress: 0,
                    duration: 2000, // 2 seconds
                    startTime: Date.now()
                });
            });
        }
        
        function updateEasing() {
            const currentTime = Date.now();
            easingObjects.forEach(obj => {
                const elapsed = currentTime - obj.startTime;
                obj.progress = Math.min(elapsed / obj.duration, 1);
                
                if (obj.progress >= 1) {
                    // Reset
                    obj.startTime = currentTime;
                    obj.progress = 0;
                }
            });
        }
        
        function drawEasing() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            easingObjects.forEach(obj => {
                const eased = easingFunctions[obj.name](obj.progress);
                const y = obj.startY + (obj.endY - obj.startY) * eased;
                
                // Draw line
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(obj.x, obj.startY);
                ctx.lineTo(obj.x, obj.endY);
                ctx.stroke();
                
                // Draw ball
                ctx.fillStyle = '#4ECDC4';
                ctx.beginPath();
                ctx.arc(obj.x, y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw label
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(obj.name, obj.x, 80);
            });
        }
        
        // ============================================
        // 2. PHYSICS SIMULATION
        // ============================================
        
        class PhysicsObject {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.radius = 10 + Math.random() * 20;
                this.mass = this.radius;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.friction = 0.98;
                this.bounce = 0.8;
            }
            
            update() {
                // Apply gravity
                this.vy += 0.2;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Apply friction
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                // Bounce off walls
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -this.bounce;
                }
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -this.bounce;
                }
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -this.bounce;
                }
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -this.bounce;
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw velocity vector
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.vx * 5, this.y + this.vy * 5);
                ctx.stroke();
            }
        }
        
        const physicsObjects = [];
        
        function initPhysics() {
            physicsObjects.length = 0;
            for (let i = 0; i < 10; i++) {
                physicsObjects.push(new PhysicsObject(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height * 0.5
                ));
            }
        }
        
        function updatePhysics() {
            physicsObjects.forEach(obj => obj.update());
            
            // Simple collision detection
            for (let i = 0; i < physicsObjects.length; i++) {
                for (let j = i + 1; j < physicsObjects.length; j++) {
                    const obj1 = physicsObjects[i];
                    const obj2 = physicsObjects[j];
                    const dx = obj2.x - obj1.x;
                    const dy = obj2.y - obj1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = obj1.radius + obj2.radius;
                    
                    if (distance < minDistance) {
                        // Collision!
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // Rotate velocities
                        const vx1 = obj1.vx * cos + obj1.vy * sin;
                        const vy1 = obj1.vy * cos - obj1.vx * sin;
                        const vx2 = obj2.vx * cos + obj2.vy * sin;
                        const vy2 = obj2.vy * cos - obj2.vx * sin;
                        
                        // Exchange velocities (simplified)
                        const finalVx1 = ((obj1.mass - obj2.mass) * vx1 + 2 * obj2.mass * vx2) / (obj1.mass + obj2.mass);
                        const finalVx2 = ((obj2.mass - obj1.mass) * vx2 + 2 * obj1.mass * vx1) / (obj1.mass + obj2.mass);
                        
                        obj1.vx = finalVx1 * cos - vy1 * sin;
                        obj1.vy = vy1 * cos + finalVx1 * sin;
                        obj2.vx = finalVx2 * cos - vy2 * sin;
                        obj2.vy = vy2 * cos + finalVx2 * sin;
                        
                        // Separate objects
                        const overlap = minDistance - distance;
                        obj1.x -= overlap * cos * 0.5;
                        obj1.y -= overlap * sin * 0.5;
                        obj2.x += overlap * cos * 0.5;
                        obj2.y += overlap * sin * 0.5;
                    }
                }
            }
        }
        
        function drawPhysics() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            physicsObjects.forEach(obj => obj.draw());
        }
        
        // ============================================
        // 3. WAVE ANIMATION
        // ============================================
        
        let waveTime = 0;
        
        function drawWave() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            waveTime += 0.05;
            
            // Draw multiple waves
            const waves = [
                { amplitude: 50, frequency: 0.02, speed: 2, color: '#4ECDC4', offset: 0 },
                { amplitude: 30, frequency: 0.03, speed: 1.5, color: '#95E1D3', offset: Math.PI / 2 },
                { amplitude: 40, frequency: 0.025, speed: 1.8, color: '#F38181', offset: Math.PI }
            ];
            
            waves.forEach(wave => {
                ctx.strokeStyle = wave.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let x = 0; x < canvas.width; x++) {
                    const y = canvas.height / 2 + 
                              Math.sin(x * wave.frequency + waveTime * wave.speed + wave.offset) * wave.amplitude;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            });
            
            // Draw particles on waves
            ctx.fillStyle = '#FFD93D';
            for (let i = 0; i < 20; i++) {
                const x = (canvas.width / 20) * i;
                const y = canvas.height / 2 + 
                          Math.sin(x * 0.02 + waveTime * 2) * 50;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ============================================
        // MAIN ANIMATION LOOP
        // ============================================
        
        function animate() {
            if (animationMode === 'easing') {
                updateEasing();
                drawEasing();
            } else if (animationMode === 'physics') {
                updatePhysics();
                drawPhysics();
            } else if (animationMode === 'wave') {
                drawWave();
            }
            
            requestAnimationFrame(animate);
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.getElementById('easingBtn').addEventListener('click', () => {
            animationMode = 'easing';
            initEasing();
        });
        
        document.getElementById('physicsBtn').addEventListener('click', () => {
            animationMode = 'physics';
            initPhysics();
        });
        
        document.getElementById('waveBtn').addEventListener('click', () => {
            animationMode = 'wave';
            waveTime = 0;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            if (animationMode === 'easing') initEasing();
            if (animationMode === 'physics') initPhysics();
            if (animationMode === 'wave') waveTime = 0;
        });
        
        // Initialize
        initEasing();
        animate();
    </script>
</body>
</html>

